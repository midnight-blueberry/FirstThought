const fs = require("fs");
const path = require("path");

const ROOT = process.cwd();
const FONTS_DIR = path.join(ROOT, "assets", "fonts");
const OUT_FILE = path.join(ROOT, "src", "constants", "fonts", "files.ts");
const USE_ALIAS = "@assets"; // предполагаем существующий алиас на /assets

const NAME_TO_WEIGHT = new Map(Object.entries({
  Thin: 100, ExtraLight: 200, Light: 300, Regular: 400,
  Medium: 500, SemiBold: 600, Bold: 700, ExtraBold: 800, Black: 900,
}));

function parseWeight(basename) {
  // пытаемся вытащить 100..900
  const num = basename.match(/(\d{3})(?!.*\d)/);
  if (num) {
    const w = Number(num[1]);
    if (w >= 100 && w <= 900 && w % 100 === 0) return w;
  }
  // или семантические имена
  for (const [name, w] of NAME_TO_WEIGHT.entries()) {
    const re = new RegExp(`(?:-|_)${name}(?:\\.|$)`, "i");
    if (re.test(basename)) return w;
  }
  // дефолт
  return 400;
}

function scan() {
  if (!fs.existsSync(FONTS_DIR)) throw new Error(`Missing ${FONTS_DIR}`);
  const families = fs.readdirSync(FONTS_DIR).filter((d) =>
    fs.statSync(path.join(FONTS_DIR, d)).isDirectory()
  );

  const registry = {};
  for (const family of families) {
    const dir = path.join(FONTS_DIR, family);
    const files = fs.readdirSync(dir).filter((f) => /\.ttf$/i.test(f));
    if (!files.length) continue;

    const weightMap = {};
    for (const file of files) {
      const basename = path.basename(file);
      const weight = parseWeight(basename);
      const aliasPath = `${USE_ALIAS}/fonts/${family}/${basename}`;
      weightMap[weight] = `require("${aliasPath}")`;
    }
    // сортировка ключей по возрастанию
    const sortedEntries = Object.entries(weightMap)
      .map(([w, req]) => [Number(w), req])
      .sort((a, b) => a[0] - b[0]);

    registry[family] = Object.fromEntries(sortedEntries);
  }
  return registry;
}

function toTs(registry) {
  const lines = [];
  lines.push("// ⚠️ AUTOGENERATED: do not edit by hand");
  lines.push("export const FONT_FILES = {");
  for (const [family, weights] of Object.entries(registry)) {
    lines.push(`  ${family}: {`);
    for (const [w, req] of Object.entries(weights)) {
      lines.push(`    ${w}: ${req},`);
    }
    lines.push("  },");
  }
  lines.push("} as const;");
  lines.push("");
  return lines.join("\n");
}

function run() {
  const reg = scan();
  const content = toTs(reg);
  if (process.argv.includes("--check")) {
    if (!fs.existsSync(OUT_FILE)) {
      console.error("fonts/files.ts is missing");
      process.exit(1);
    }
    const current = fs.readFileSync(OUT_FILE, "utf8");
    if (current !== content) {
      console.error("fonts/files.ts is out of date. Run: npm run gen:fonts");
      process.exit(1);
    }
    process.exit(0);
  } else {
    fs.mkdirSync(path.dirname(OUT_FILE), { recursive: true });
    fs.writeFileSync(OUT_FILE, content, "utf8");
    console.log(`Updated ${path.relative(ROOT, OUT_FILE)}`);
  }
}

run();
